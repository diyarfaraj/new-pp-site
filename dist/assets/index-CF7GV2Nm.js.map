{"version":3,"file":"index-CF7GV2Nm.js","sources":["../../src/main.ts"],"sourcesContent":["/**\r\n * Portfolio Website - Main TypeScript\r\n * Diyar Faraj - Software Engineer\r\n *\r\n * Features:\r\n * - Matrix-style messenger animation with cycling text\r\n * - Falling matrix rain background effect\r\n * - First name glitch/flicker effect\r\n *\r\n * No external dependencies - Pure Vanilla TypeScript\r\n */\r\n\r\n// ======================\r\n// TYPE DEFINITIONS\r\n// ======================\r\n\r\ninterface FadeBufferItem {\r\n  c: number;\r\n  l: string;\r\n  flicker: boolean;\r\n}\r\n\r\ninterface DimState {\r\n  shadow: string;\r\n  color: string;\r\n}\r\n\r\n// ======================\r\n// TYPEWRITER EFFECT\r\n// ======================\r\n\r\n/**\r\n * TypeWriter class - Creates command-line style typing effect\r\n * Types text character by character with blinking cursor\r\n */\r\nclass TypeWriter {\r\n  private element: HTMLElement;\r\n  private cursorElement: HTMLElement;\r\n  private text: string;\r\n  private currentIndex: number;\r\n  private minDelay: number;\r\n  private maxDelay: number;\r\n\r\n  constructor(element: HTMLElement, cursorElement: HTMLElement, text: string) {\r\n    this.element = element;\r\n    this.cursorElement = cursorElement;\r\n    this.text = text;\r\n    this.currentIndex = 0;\r\n    this.minDelay = 80;\r\n    this.maxDelay = 120;\r\n  }\r\n\r\n  /**\r\n   * Show blinking cursor and wait before starting to type\r\n   */\r\n  async showCursor(delay: number = 700): Promise<void> {\r\n    this.cursorElement.style.display = 'inline';\r\n    return new Promise(resolve => setTimeout(resolve, delay));\r\n  }\r\n\r\n  /**\r\n   * Type text character by character\r\n   */\r\n  async type(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      const typeChar = () => {\r\n        if (this.currentIndex < this.text.length) {\r\n          this.element.textContent = this.text.substring(0, this.currentIndex + 1);\r\n          this.currentIndex++;\r\n          const delay = this.minDelay + Math.random() * (this.maxDelay - this.minDelay);\r\n          setTimeout(typeChar, delay);\r\n        } else {\r\n          resolve();\r\n        }\r\n      };\r\n      typeChar();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop cursor blinking but keep it visible\r\n   */\r\n  stopCursorBlink(): void {\r\n    this.cursorElement.classList.add('static');\r\n  }\r\n\r\n  /**\r\n   * Complete typing sequence: show cursor, type, stop blink\r\n   */\r\n  async execute(): Promise<void> {\r\n    await this.showCursor();\r\n    await this.type();\r\n    this.stopCursorBlink();\r\n  }\r\n}\r\n\r\n// ======================\r\n// MESSENGER ANIMATION\r\n// ======================\r\n\r\n/**\r\n * Messenger class - Creates Matrix-style typing animation\r\n * Cycles through messages with random character effects\r\n */\r\nclass Messenger {\r\n  private textEl: HTMLElement;\r\n  private codeletters: string;\r\n  private message: number;\r\n  private current_length: number;\r\n  private fadeBuffer: FadeBufferItem[] | false;\r\n  private glitchInterval: number | null;\r\n  private messages: string[];\r\n\r\n  constructor(textEl: HTMLElement) {\r\n    this.textEl = textEl;\r\n    this.codeletters = '';\r\n    this.message = 0;\r\n    this.current_length = 0;\r\n    this.fadeBuffer = false;\r\n    this.glitchInterval = null;\r\n    this.messages = [];\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * Initialize the messenger with configuration and styling\r\n   */\r\n  private init(): void {\r\n    // Matrix-like character set including Japanese-inspired symbols\r\n    this.codeletters = \"ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ01010101\";\r\n\r\n    // Current message index\r\n    this.message = 0;\r\n\r\n    // Current character length being animated\r\n    this.current_length = 0;\r\n\r\n    // Buffer for fade-in effect\r\n    this.fadeBuffer = false;\r\n\r\n    // Interval for glitch effect\r\n    this.glitchInterval = null;\r\n\r\n    // Messages to cycle through (prompt is static in HTML)\r\n    this.messages = [\r\n      \"Software Engineer\",\r\n      \"C#/.NET\",\r\n      \"DevOps\",\r\n      \"Kubernetes\",\r\n      \"Linux\",\r\n      \"Azure\",\r\n    ];\r\n\r\n    // Start the glitch effect\r\n    this.startGlitchEffect();\r\n\r\n    // Note: Animation start is now controlled externally via startAnimation()\r\n  }\r\n\r\n  /**\r\n   * Start the messenger cycling animation\r\n   * Call this after initial typing effect is complete\r\n   */\r\n  public startAnimation(): void {\r\n    setTimeout(() => this.animateIn(), 100);\r\n  }\r\n\r\n  /**\r\n   * Starts random glitch effect on text\r\n   */\r\n  private startGlitchEffect(): void {\r\n    this.glitchInterval = window.setInterval(() => {\r\n      if (Math.random() < 0.1) {\r\n        const originalText = this.textEl.textContent || '';\r\n        const glitchText = originalText.split('').map(char =>\r\n          Math.random() < 0.3\r\n            ? this.codeletters.charAt(Math.floor(Math.random() * this.codeletters.length))\r\n            : char\r\n        ).join('');\r\n\r\n        this.textEl.textContent = glitchText;\r\n\r\n        // Restore after brief glitch\r\n        setTimeout(() => {\r\n          this.textEl.textContent = originalText;\r\n        }, 50 + Math.random() * 100);\r\n      }\r\n    }, 1000);\r\n  }\r\n\r\n  /**\r\n   * Generates random string of specified length from codeletters\r\n   */\r\n  private generateRandomString(length: number): string {\r\n    let random_text = \"\";\r\n    while (random_text.length < length) {\r\n      random_text += this.codeletters.charAt(\r\n        Math.floor(Math.random() * this.codeletters.length)\r\n      );\r\n    }\r\n    return random_text;\r\n  }\r\n\r\n  /**\r\n   * Animates text in with random characters\r\n   */\r\n  private animateIn(): void {\r\n    if (this.current_length < this.messages[this.message].length) {\r\n      // Speed varies slightly for more organic feeling\r\n      this.current_length = this.current_length + (Math.random() < 0.3 ? 1 : 2);\r\n      if (this.current_length > this.messages[this.message].length) {\r\n        this.current_length = this.messages[this.message].length;\r\n      }\r\n\r\n      const message = this.generateRandomString(this.current_length);\r\n      this.textEl.textContent = message;\r\n\r\n      // Slightly randomized timing\r\n      setTimeout(() => this.animateIn(), 10 + Math.random() * 30);\r\n    } else {\r\n      setTimeout(() => this.animateFadeBuffer(), 20);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fades in actual message characters from random characters\r\n   */\r\n  private animateFadeBuffer(): void {\r\n    if (this.fadeBuffer === false) {\r\n      this.fadeBuffer = [];\r\n      for (let i = 0; i < this.messages[this.message].length; i++) {\r\n        this.fadeBuffer.push({\r\n          c: Math.floor(Math.random() * 18) + 1, // More iterations for matrix-like effect\r\n          l: this.messages[this.message].charAt(i),\r\n          flicker: Math.random() < 0.4, // Some characters will flicker\r\n        });\r\n      }\r\n    }\r\n\r\n    let do_cycles = false;\r\n    let message = \"\";\r\n\r\n    for (let i = 0; i < this.fadeBuffer.length; i++) {\r\n      const fader = this.fadeBuffer[i];\r\n      if (fader.c > 0) {\r\n        do_cycles = true;\r\n        fader.c--;\r\n        message += this.codeletters.charAt(\r\n          Math.floor(Math.random() * this.codeletters.length)\r\n        );\r\n      } else {\r\n        // Occasionally flicker even after character is revealed\r\n        if (fader.flicker && Math.random() < 0.03) {\r\n          message += this.codeletters.charAt(\r\n            Math.floor(Math.random() * this.codeletters.length)\r\n          );\r\n        } else {\r\n          message += fader.l;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.textEl.textContent = message;\r\n\r\n    if (do_cycles === true) {\r\n      setTimeout(() => this.animateFadeBuffer(), 40 + Math.random() * 20);\r\n    } else {\r\n      setTimeout(() => this.cycleText(), 2000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cycles to next message\r\n   */\r\n  private cycleText(): void {\r\n    this.message = this.message + 1;\r\n    if (this.message >= this.messages.length) {\r\n      this.message = 0;\r\n    }\r\n\r\n    this.current_length = 0;\r\n    this.fadeBuffer = false;\r\n    this.textEl.textContent = \"\";\r\n\r\n    setTimeout(() => this.animateIn(), 200);\r\n  }\r\n\r\n  /**\r\n   * Cleanup function to remove intervals\r\n   */\r\n  public destroy(): void {\r\n    if (this.glitchInterval) {\r\n      clearInterval(this.glitchInterval);\r\n    }\r\n  }\r\n}\r\n\r\n// ======================\r\n// MATRIX RAIN EFFECT\r\n// ======================\r\n\r\n/**\r\n * Creates falling matrix rain characters in background\r\n */\r\nfunction createMatrixRain(): void {\r\n  const matrixBg = document.getElementById('matrix-bg');\r\n  if (!matrixBg) return;\r\n\r\n  const width = window.innerWidth;\r\n  const charCount = Math.floor(width / 20); // Approx number of columns\r\n\r\n  for (let i = 0; i < charCount; i++) {\r\n    const column = document.createElement('div');\r\n    column.className = 'matrix-column';\r\n\r\n    Object.assign(column.style, {\r\n      left: (i * 20) + 'px',\r\n      animationDelay: (Math.random() * 5) + 's',\r\n      position: 'absolute',\r\n      top: '0',\r\n      color: '#0f0',\r\n      fontSize: '4px',\r\n      textShadow: '0 0 5px #0f0',\r\n      opacity: (0.1 + Math.random() * 0.5).toString()\r\n    });\r\n\r\n    const height = Math.floor(Math.random() * 30) + 10;\r\n    for (let j = 0; j < height; j++) {\r\n      const char = document.createElement('div');\r\n      char.textContent = \"ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ01010101\".charAt(\r\n        Math.floor(Math.random() * \"ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ01010101\".length)\r\n      );\r\n      char.style.animation = `matrix-fall ${5 + Math.random() * 10}s linear infinite`;\r\n      char.style.animationDelay = (j * 0.1) + 's';\r\n      column.appendChild(char);\r\n    }\r\n\r\n    matrixBg.appendChild(column);\r\n  }\r\n}\r\n\r\n// ======================\r\n// FIRST NAME GLITCH EFFECT\r\n// ======================\r\n\r\n/**\r\n * Adds glitching effect to first name with flickering light\r\n */\r\nfunction glitchFirstName(): void {\r\n  const firstNameEl = document.querySelector('.text-secondary') as HTMLElement | null;\r\n  if (!firstNameEl) return;\r\n\r\n  // Store the original text\r\n  const originalText = firstNameEl.textContent || '';\r\n\r\n  // Matrix-like characters\r\n  const matrixChars = \"ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ01010101\";\r\n\r\n  // Apply Matrix styling\r\n  Object.assign(firstNameEl.style, {\r\n    color: '#0f0',\r\n    textShadow: '0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0',\r\n    transition: 'text-shadow 0.05s, color 0.05s'\r\n  });\r\n\r\n  // Normal bright glow state\r\n  const normalGlow = '0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0';\r\n  const normalColor = '#0f0';\r\n\r\n  // Different dimmer states to simulate flickering\r\n  const dimStates: DimState[] = [\r\n    { shadow: '0 0 8px #0f0, 0 0 15px #0f0', color: '#0c0' },\r\n    { shadow: '0 0 5px #0a0', color: '#0a0' },\r\n    { shadow: '0 0 3px #080', color: '#080' },\r\n    { shadow: 'none', color: '#050' }  // Almost burned out\r\n  ];\r\n\r\n  /**\r\n   * Flickers the light randomly\r\n   */\r\n  function flickerLight(): void {\r\n    // 25% chance of flicker occurring\r\n    if (Math.random() < 0.25) {\r\n      // Choose how severe the flicker is\r\n      let severity: number;\r\n      const rand = Math.random();\r\n\r\n      if (rand < 0.6) {\r\n        // Minor flicker (60% chance)\r\n        severity = 0;\r\n      } else if (rand < 0.9) {\r\n        // Medium flicker (30% chance)\r\n        severity = 1;\r\n      } else {\r\n        // Major flicker/brownout (10% chance)\r\n        severity = Math.floor(Math.random() * 2) + 2; // Either 2 or 3\r\n      }\r\n\r\n      // Apply the flicker effect\r\n      firstNameEl!.style.textShadow = dimStates[severity].shadow;\r\n      firstNameEl!.style.color = dimStates[severity].color;\r\n\r\n      // Sometimes have multiple flickers in succession\r\n      const flickers = (Math.random() < 0.3) ? Math.floor(Math.random() * 3) + 2 : 1;\r\n      let flickerCount = 0;\r\n\r\n      // Function to flicker back and forth\r\n      function singleFlicker(): void {\r\n        setTimeout(() => {\r\n          // Flip between dim and normal\r\n          if (flickerCount % 2 === 0) {\r\n            // Back to normal\r\n            firstNameEl!.style.textShadow = normalGlow;\r\n            firstNameEl!.style.color = normalColor;\r\n          } else {\r\n            // Dim again, possibly with different intensity\r\n            const newSeverity = Math.min(Math.floor(Math.random() * 4), 3);\r\n            firstNameEl!.style.textShadow = dimStates[newSeverity].shadow;\r\n            firstNameEl!.style.color = dimStates[newSeverity].color;\r\n          }\r\n\r\n          flickerCount++;\r\n          if (flickerCount < flickers * 2) {\r\n            singleFlicker();\r\n          }\r\n        }, 30 + Math.random() * 100); // Random timing between flickers\r\n      }\r\n\r\n      singleFlicker();\r\n    }\r\n  }\r\n\r\n  // Set up occasional glitching and flickering\r\n  setInterval(() => {\r\n    // Glitch characters occasionally (20% chance)\r\n    if (Math.random() < 0.2) {\r\n      // Create a glitched version of the text\r\n      const textArray = originalText.split('');\r\n\r\n      // Randomly replace 1-2 characters\r\n      const numGlitches = Math.floor(Math.random() * 2) + 1;\r\n      for (let i = 0; i < numGlitches; i++) {\r\n        const glitchPos = Math.floor(Math.random() * textArray.length);\r\n        textArray[glitchPos] = matrixChars.charAt(\r\n          Math.floor(Math.random() * matrixChars.length)\r\n        );\r\n      }\r\n\r\n      // Apply glitched text\r\n      firstNameEl!.textContent = textArray.join('');\r\n\r\n      // Reset after a brief moment (50-150ms)\r\n      setTimeout(() => {\r\n        firstNameEl!.textContent = originalText;\r\n      }, 50 + Math.random() * 100);\r\n    }\r\n\r\n    // Check for light flicker with independent timing\r\n    flickerLight();\r\n\r\n  }, 800); // Check for potential effects every 800ms\r\n}\r\n\r\n// ======================\r\n// CSS ANIMATIONS\r\n// ======================\r\n\r\n/**\r\n * Injects CSS keyframe animations for matrix effects\r\n */\r\nfunction injectMatrixAnimations(): void {\r\n  const style = document.createElement('style');\r\n  style.textContent = `\r\n    @keyframes matrix-fall {\r\n      0% { transform: translateY(-100vh); opacity: 1; }\r\n      80% { opacity: 0.8; }\r\n      100% { transform: translateY(100vh); opacity: 0; }\r\n    }\r\n\r\n    .matrix-column {\r\n      animation: matrix-sway 3s ease-in-out infinite alternate;\r\n    }\r\n\r\n    @keyframes matrix-sway {\r\n      from { transform: translateX(-10px); }\r\n      to { transform: translateX(10px); }\r\n    }\r\n  `;\r\n  document.head.appendChild(style);\r\n}\r\n\r\n// ======================\r\n// INITIALIZATION\r\n// ======================\r\n\r\n/**\r\n * Initialize all effects when DOM is ready\r\n */\r\ndocument.addEventListener('DOMContentLoaded', async () => {\r\n  // Get all required elements\r\n  const nameTextEl = document.getElementById('name-text');\r\n  const nameCursorEl = document.querySelector('h1 .cursor') as HTMLElement;\r\n  const messengerTextEl = document.getElementById('messenger-text');\r\n  const messengerCursorEl = document.querySelector('#messenger .cursor') as HTMLElement;\r\n\r\n  if (nameTextEl && nameCursorEl && messengerTextEl && messengerCursorEl) {\r\n    // 1. Type name first (prompt is static in HTML)\r\n    const nameTyper = new TypeWriter(nameTextEl, nameCursorEl, 'Diyar Faraj');\r\n    await nameTyper.execute();\r\n\r\n    // 2. Small delay before messenger starts typing\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n\r\n    // 3. Initialize messenger (but don't start cycling yet)\r\n    const messenger = new Messenger(messengerTextEl);\r\n\r\n    // 4. Type first messenger message (prompt is static in HTML)\r\n    const firstMessage = 'Software Engineer';\r\n    const messengerTyper = new TypeWriter(messengerTextEl, messengerCursorEl, firstMessage);\r\n    await messengerTyper.execute();\r\n\r\n    // 5. Start messenger cycling animation\r\n    messenger.startAnimation();\r\n\r\n    // 6. Enable name glitch effect after everything is typed\r\n    setTimeout(glitchFirstName, 500);\r\n  }\r\n\r\n  // Inject CSS animations (keeping for potential future use)\r\n  // injectMatrixAnimations();\r\n\r\n  // Matrix rain effect disabled - using background image instead\r\n  // setTimeout(createMatrixRain, 300);\r\n});\r\n"],"names":["TypeWriter","element","cursorElement","text","__publicField","delay","resolve","typeChar","Messenger","textEl","originalText","glitchText","char","length","random_text","message","i","do_cycles","fader","glitchFirstName","firstNameEl","matrixChars","normalGlow","normalColor","dimStates","flickerLight","singleFlicker","flickerCount","newSeverity","flickers","severity","rand","textArray","numGlitches","glitchPos","nameTextEl","nameCursorEl","messengerTextEl","messengerCursorEl","messenger","firstMessage"],"mappings":"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"}